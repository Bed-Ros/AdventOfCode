--- День 3: Обдумайте это ---
    «У нас проблемы с компьютерами, так что я понятия не имею, есть ли у нас в наличии главные историки!
Но вы можете проверить склад», — говорит слегка взволнованный продавец в магазине проката тобогганов «Северный полюс».
Историки отправляются посмотреть.
    Продавец поворачивается к вам: «Вы случайно не понимаете, почему у нас снова проблемы с компьютерами?»
    Похоже, компьютер пытается запустить программу, но его память (входные данные для головоломки) повреждена.
Все инструкции перепутаны!
    Похоже, цель программы — просто умножить несколько чисел. Она делает это с помощью инструкций вида mul(X,Y),
где X и Y — числа от 1 до 3 цифр. Например, mul(44,46) умножает 44 на 46 чтобы получить результат 2024.
Аналогично, mul(123,4) умножает 123 на 4.
    Однако, поскольку память программы повреждена, в ней также присутствует множество недопустимых символов,
которые следует игнорировать, даже если они выглядят как часть mul инструкции.
Последовательности типа mul(4*, mul(6,9!, ?(12,34), или mul ( 2 , 4 ) не выполняют никаких действий.

Например, рассмотрим следующий фрагмент поврежденной памяти:
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))

    Только четыре раздела являются настоящими mul инструкциями. Сложение результатов каждой инструкции
даёт 161 (2*4 + 5*5 + 11*8 + 8*5).

Просканируйте повреждённую память на наличие неповреждённых mul инструкций. Что получится, если сложить все результаты умножений?

--- Часть вторая ---
    Просматривая повреждённую память, вы замечаете, что некоторые условные операторы остались нетронутыми.
Если вы обработаете некоторые неповреждённые условные операторы в программе, вы, возможно, сможете получить ещё более точный результат.

Вам придется выполнить две новые инструкции:
    Инструкция do() дает возможность применять будущие инструкции mul
    Инструкция don't() отключает будущие инструкции mul
    Применяются только самые последние do() инструкции don't(). В начале программы mul инструкции включены.

Например:
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))

    Эта повреждённая память похожа на предыдущий пример, но на этот раз инструкции mul(5,5) и mul(11,8) отключены,
поскольку перед ними находится инструкция don't(). Остальные инструкции работают нормально, включая ту,
что в конце mul(11,8), которая снова активируется инструкцией do()

На этот раз сумма результатов равна 48(2*4 + 8*5).

Разберитесь с новыми инструкциями: что получится, если сложить все результаты только включенных умножений?